---
sidebar: sidebar 
permalink: data-analytics/kafka-tech-overview.html 
keywords: storagegrid, apache, confluent, kafka, grid manager, 
summary: 이 섹션에서는 이 솔루션에 사용된 기술에 대해 설명합니다. 
---
= 기술 개요
:hardbreaks:
:allow-uri-read: 
:nofooter: 
:icons: font
:linkattrs: 
:imagesdir: ../media/


[role="lead"]
이 섹션에서는 이 솔루션에 사용된 기술에 대해 설명합니다.



== NetApp StorageGRID

NetApp StorageGRID 는 고성능, 비용 효율적인 객체 스토리지 플랫폼입니다.  계층형 스토리지를 사용하면 브로커의 로컬 스토리지나 SAN 스토리지에 저장된 Confluent Kafka의 대부분 데이터가 원격 개체 저장소로 오프로드됩니다.  이 구성은 클러스터를 재조정, 확장 또는 축소하거나 실패한 브로커를 교체하는 데 드는 시간과 비용을 줄여 운영을 크게 개선합니다.  개체 스토리지는 개체 스토리지 계층에 있는 데이터를 관리하는 데 중요한 역할을 하므로 올바른 개체 스토리지를 선택하는 것이 중요합니다.

StorageGRID 분산된 노드 기반 그리드 아키텍처를 사용하여 지능적이고 정책 기반의 글로벌 데이터 관리를 제공합니다.  유비쿼터스 글로벌 객체 네임스페이스와 정교한 데이터 관리 기능을 결합하여 페타바이트 규모의 비정형 데이터와 수십억 개의 객체를 간편하게 관리할 수 있습니다.  단일 호출 객체 액세스는 여러 사이트로 확장되어 고가용성 아키텍처를 단순화하는 동시에 사이트나 인프라 중단에 관계없이 지속적인 객체 액세스를 보장합니다.

멀티테넌시를 통해 여러 개의 비정형 클라우드 및 엔터프라이즈 데이터 애플리케이션을 동일한 그리드 내에서 안전하게 서비스할 수 있어 NetApp StorageGRID 의 ROI와 사용 사례가 늘어납니다.  메타데이터 기반 개체 수명 주기 정책을 통해 여러 서비스 수준을 생성하여 여러 지역에 걸쳐 내구성, 보호, 성능 및 지역성을 최적화할 수 있습니다.  사용자는 끊임없이 변화하는 IT 환경에서 요구 사항이 바뀌더라도 데이터 관리 정책을 조정하고 트래픽 제한을 모니터링하여 데이터 환경에 맞게 중단 없이 재조정할 수 있습니다.



=== Grid Manager를 통한 간편한 관리

StorageGRID Grid Manager는 브라우저 기반 그래픽 인터페이스로, 단일 창에서 전 세계에 분산된 위치에 있는 StorageGRID 시스템을 구성, 관리 및 모니터링할 수 있습니다.

image:confluent-kafka-004.png["입력/출력 대화 상자 또는 서면 내용을 나타내는 그림"]

StorageGRID Grid Manager 인터페이스를 사용하여 다음 작업을 수행할 수 있습니다.

* 이미지, 비디오, 기록 등의 객체가 담긴 페타바이트 규모의 글로벌 분산 저장소를 관리합니다.
* 그리드 노드와 서비스를 모니터링하여 객체 가용성을 보장합니다.
* 정보 수명 주기 관리(ILM) 규칙을 사용하여 시간 경과에 따른 개체 데이터의 배치를 관리합니다.  이러한 규칙은 객체 데이터가 수집된 후 어떻게 처리되는지, 데이터가 손실로부터 어떻게 보호되는지, 객체 데이터가 어디에 저장되는지, 얼마 동안 저장되는지를 관리합니다.
* 시스템 내에서 거래, 성능 및 운영을 모니터링합니다.




=== 정보 수명 주기 관리 정책

StorageGRID 개체의 복제본을 보관하고 2+1, 4+2 등과 같은 EC(삭제 코딩) 방식을 사용하여 특정 성능 및 데이터 보호 요구 사항에 따라 개체를 저장하는 등 유연한 데이터 관리 정책을 제공합니다.  시간이 지남에 따라 작업 부하와 요구 사항이 바뀌므로 ILM 정책도 시간이 지남에 따라 변경해야 하는 것이 일반적입니다.  ILM 정책을 수정하는 것은 StorageGRID 고객이 끊임없이 변화하는 환경에 빠르고 쉽게 적응할 수 있도록 하는 핵심 기능입니다.



=== 성능

StorageGRID VM, 베어 메탈 또는 특수 목적 어플라이언스와 같은 더 많은 스토리지 노드를 추가하여 성능을 확장합니다.link:https://www.netapp.com/pdf.html?item=/media/7931-ds-3613.pdf["SG5712, SG5760, SG6060 또는 SGF6024"^] .  테스트 결과, SGF6024 어플라이언스를 사용하여 최소 크기의 3노드 그리드로 Apache Kafka의 주요 성능 요구 사항을 충족했습니다.  고객이 추가 브로커를 사용하여 Kafka 클러스터를 확장하면 더 많은 스토리지 노드를 추가하여 성능과 용량을 늘릴 수 있습니다.



=== 로드 밸런서 및 엔드포인트 구성

StorageGRID 의 관리 노드는 StorageGRID 시스템을 보고, 구성하고, 관리할 수 있는 Grid Manager UI(사용자 인터페이스)와 REST API 엔드포인트를 제공하며, 시스템 활동을 추적하기 위한 감사 로그를 제공합니다.  Confluent Kafka 계층형 스토리지에 고가용성 S3 엔드포인트를 제공하기 위해 관리 노드와 게이트웨이 노드에서 서비스로 실행되는 StorageGRID 로드 밸런서를 구현했습니다.  또한, 로드 밸런서는 로컬 트래픽을 관리하고 GSLB(글로벌 서버 로드 밸런싱)와 통신하여 재해 복구를 지원합니다.

엔드포인트 구성을 더욱 향상시키기 위해 StorageGRID 관리 노드에 내장된 트래픽 분류 정책을 제공하고, 워크로드 트래픽을 모니터링하고, 워크로드에 다양한 서비스 품질(QoS) 제한을 적용할 수 있도록 합니다.  트래픽 분류 정책은 게이트웨이 노드와 관리 노드에 대한 StorageGRID 부하 분산 서비스의 엔드포인트에 적용됩니다.  이러한 정책은 트래픽 조절 및 모니터링에 도움이 될 수 있습니다.



=== StorageGRID 의 트래픽 분류

StorageGRID 에는 QoS 기능이 내장되어 있습니다.  트래픽 분류 정책은 클라이언트 애플리케이션에서 발생하는 다양한 유형의 S3 트래픽을 모니터링하는 데 도움이 될 수 있습니다.  그런 다음 입출력 대역폭, 동시 읽기/쓰기 요청 수 또는 읽기/쓰기 요청 속도를 기준으로 이 트래픽에 제한을 두는 정책을 만들고 적용할 수 있습니다.



== 아파치 카프카

Apache Kafka는 Java와 Scala로 작성된 스트림 처리를 사용하는 소프트웨어 버스의 프레임워크 구현입니다.  실시간 데이터 피드를 처리하기 위한 통합적이고 처리량이 높으며 지연 시간이 짧은 플랫폼을 제공하는 것이 목표입니다.  Kafka는 Kafka Connect를 통해 외부 시스템에 연결하여 데이터를 내보내고 가져올 수 있으며, Java 스트림 처리 라이브러리인 Kafka 스트림을 제공합니다.  카프카는 효율성을 위해 최적화된 바이너리 TCP 기반 프로토콜을 사용하며, 네트워크 왕복 오버헤드를 줄이기 위해 자연스럽게 메시지를 그룹화하는 "메시지 세트" 추상화에 의존합니다.  이를 통해 더 큰 순차적 디스크 작업, 더 큰 네트워크 패킷, 연속적인 메모리 블록이 가능해져서 Kafka는 무작위 메시지 쓰기의 버스트 스트림을 선형 쓰기로 전환할 수 있습니다.  다음 그림은 Apache Kafka의 기본적인 데이터 흐름을 보여줍니다.

image:confluent-kafka-005.png["입력/출력 대화 상자 또는 서면 내용을 나타내는 그림"]

카프카는 프로듀서라고 불리는 임의의 수의 프로세스에서 나온 키-값 메시지를 저장합니다.  데이터는 다양한 주제 내에서 여러 파티션으로 분할될 수 있습니다.  파티션 내에서 메시지는 오프셋(파티션 내 메시지의 위치)에 따라 엄격하게 정렬되고, 타임스탬프와 함께 인덱싱되어 저장됩니다.  소비자라고 불리는 다른 프로세스는 파티션에서 메시지를 읽을 수 있습니다.  스트림 처리를 위해 Kafka는 Kafka에서 데이터를 사용하고 결과를 Kafka로 다시 쓰는 Java 애플리케이션을 작성할 수 있는 Streams API를 제공합니다.  Apache Kafka는 Apache Apex, Apache Flink, Apache Spark, Apache Storm, Apache NiFi와 같은 외부 스트림 처리 시스템과도 호환됩니다.

카프카는 하나 이상의 서버(브로커라고 함)로 구성된 클러스터에서 실행되며, 모든 토픽의 파티션은 클러스터 노드에 분산됩니다.  또한 파티션은 여러 브로커에 복제됩니다.  이 아키텍처를 통해 Kafka는 장애 허용 방식으로 대량의 메시지 스트림을 전달할 수 있었고, Java Message Service(JMS), Advanced Message Queuing Protocol(AMQP) 등 기존 메시징 시스템 중 일부를 대체할 수 있었습니다.  0.11.0.0 릴리스 이후 Kafka는 Streams API를 사용하여 정확히 한 번의 스트림 처리를 제공하는 트랜잭션 쓰기 기능을 제공합니다.

카프카는 일반 토픽과 압축 토픽의 두 가지 유형을 지원합니다.  일반 주제는 보존 시간이나 공간 제한을 사용하여 구성할 수 있습니다.  지정된 보존 시간보다 오래된 레코드가 있거나 파티션의 공간 제한을 초과하는 경우 Kafka는 오래된 데이터를 삭제하여 저장 공간을 확보할 수 있습니다.  기본적으로 주제는 7일의 보존 기간으로 구성되지만, 무기한으로 데이터를 저장하는 것도 가능합니다.  압축된 주제의 경우 레코드는 시간이나 공간 경계에 따라 만료되지 않습니다.  대신, 카프카는 이후 메시지를 동일한 키를 가진 이전 메시지의 업데이트로 처리하고 키별로 최신 메시지를 삭제하지 않도록 보장합니다.  사용자는 특정 키에 null 값을 지정하여 소위 '툼스톤' 메시지를 작성하여 메시지를 완전히 삭제할 수 있습니다.

Kafka에는 5가지 주요 API가 있습니다.

* *생산자 API.*  레코드 스트림을 게시할 수 있는 애플리케이션을 허용합니다.
* *소비자 API.*  애플리케이션이 주제를 구독하고 레코드 스트림을 처리할 수 있도록 허용합니다.
* *커넥터 API.*  주제를 기존 애플리케이션에 연결할 수 있는 재사용 가능한 생산자 및 소비자 API를 실행합니다.
* *스트림 API.*  이 API는 입력 스트림을 출력으로 변환하고 결과를 생성합니다.
* *관리자 API.*  Kafka 토픽, 브로커 및 기타 Kafka 객체를 관리하는 데 사용됩니다.


소비자 및 생산자 API는 Kafka 메시징 프로토콜을 기반으로 구축되었으며 Java로 작성된 Kafka 소비자 및 생산자 클라이언트에 대한 참조 구현을 제공합니다.  기본 메시징 프로토콜은 개발자가 어떤 프로그래밍 언어로든 자체 소비자 또는 생산자 클라이언트를 작성하는 데 사용할 수 있는 바이너리 프로토콜입니다.  이렇게 하면 Kafka가 Java Virtual Machine(JVM) 생태계에서 해제됩니다.  사용 가능한 비Java 클라이언트 목록은 Apache Kafka 위키에서 관리됩니다.



=== Apache Kafka 사용 사례

Apache Kafka는 메시징, 웹사이트 활동 추적, 메트릭, 로그 집계, 스트림 처리, 이벤트 소싱 및 커밋 로깅에 가장 많이 사용됩니다.

* 카프카는 처리량이 개선되었고, 분할 기능, 복제 기능, 내결함성 등이 내장되어 있어 대규모 메시지 처리 애플리케이션에 적합한 솔루션입니다.
* 카프카는 사용자 활동(페이지 뷰, 검색)을 추적 파이프라인에서 실시간 게시-구독 피드 세트로 재구성할 수 있습니다.
* 카프카는 종종 운영 모니터링 데이터에 사용됩니다.  여기에는 분산된 애플리케이션의 통계를 집계하여 운영 데이터의 중앙 집중식 피드를 생성하는 작업이 포함됩니다.
* 많은 사람들이 로그 집계 솔루션의 대체 솔루션으로 Kafka를 사용합니다.  로그 집계는 일반적으로 서버에서 물리적인 로그 파일을 수집하여 처리를 위해 중앙 장소(예: 파일 서버나 HDFS)에 저장합니다.  카프카는 파일 세부 정보를 추상화하고 로그나 이벤트 데이터를 메시지 스트림으로 더욱 깔끔하게 추상화합니다.  이를 통해 처리 지연 시간을 줄이고 여러 데이터 소스와 분산된 데이터 소비에 대한 지원을 보다 쉽게 할 수 있습니다.
* 많은 카프카 사용자는 여러 단계로 구성된 처리 파이프라인에서 데이터를 처리합니다. 여기서 원시 입력 데이터는 카프카 토픽에서 소비된 후 집계, 강화되거나 추가 소비 또는 후속 처리를 위해 새로운 토픽으로 변환됩니다.  예를 들어, 뉴스 기사를 추천하는 처리 파이프라인은 RSS 피드에서 기사 콘텐츠를 크롤링하여 "기사" 주제에 게시할 수 있습니다.  추가 처리 단계에서는 이 콘텐츠를 정규화하거나 중복을 제거하고 정리된 기사 콘텐츠를 새로운 주제에 게시할 수 있으며, 최종 처리 단계에서는 이 콘텐츠를 사용자에게 추천하려고 시도할 수 있습니다.  이러한 처리 파이프라인은 개별 주제를 기반으로 실시간 데이터 흐름의 그래프를 생성합니다.
* 이벤트 소싱은 상태 변경 사항을 시간순으로 기록하는 애플리케이션 디자인 스타일입니다.  Kafka는 매우 큰 규모의 저장된 로그 데이터를 지원하므로 이 스타일로 구축된 애플리케이션에 적합한 백엔드입니다.
* 카프카는 분산 시스템에 대한 일종의 외부 커밋 로그 역할을 할 수 있습니다.  로그는 노드 간에 데이터를 복제하는 데 도움이 되며, 실패한 노드가 데이터를 복원할 수 있는 재동기화 메커니즘 역할을 합니다.  Kafka의 로그 압축 기능은 이러한 사용 사례를 지원하는 데 도움이 됩니다.




== 지류

Confluent Platform은 Kafka를 고급 기능으로 완성하여 애플리케이션 개발 및 연결을 가속화하고, 스트림 처리를 통해 변환을 지원하고, 대규모 기업 운영을 단순화하고, 엄격한 아키텍처 요구 사항을 충족하는 엔터프라이즈급 플랫폼입니다.  Apache Kafka의 최초 개발자가 개발한 Confluent는 Kafka의 이점을 엔터프라이즈급 기능으로 확장하는 동시에 Kafka 관리나 모니터링의 부담을 제거합니다.  오늘날 Fortune 100 기업 중 80% 이상이 데이터 스트리밍 기술을 사용하고 있으며, 그 중 대부분은 Confluent를 사용합니다.



=== 왜 Confluent를 선택해야 할까요?

Confluent는 과거 데이터와 실시간 데이터를 단일의 중앙 진실 소스로 통합하여 완전히 새로운 종류의 최신 이벤트 중심 애플리케이션을 쉽게 구축하고, 보편적인 데이터 파이프라인을 확보하고, 완전한 확장성, 성능, 안정성을 갖춘 강력한 새로운 사용 사례를 창출할 수 있도록 지원합니다.



=== Confluent는 무엇에 사용되나요?

Confluent Platform을 사용하면 여러 시스템 간에 데이터가 전송되거나 통합되는 방식과 같은 기본적인 메커니즘에 대해 걱정하는 대신 데이터에서 비즈니스 가치를 도출하는 방법에 집중할 수 있습니다.  특히, Confluent Platform은 Kafka에 대한 데이터 소스 연결, 스트리밍 애플리케이션 구축, Kafka 인프라의 보안, 모니터링 및 관리를 간소화합니다.  오늘날 Confluent Platform은 금융 서비스, 옴니채널 소매, 자율주행차부터 사기 탐지, 마이크로서비스, IoT까지 다양한 산업에 걸쳐 광범위한 사용 사례에 사용되고 있습니다.

다음 그림은 Confluent Kafka 플랫폼 구성 요소를 보여줍니다.

image:confluent-kafka-006.png["입력/출력 대화 상자 또는 서면 내용을 나타내는 그림"]



=== Confluent의 이벤트 스트리밍 기술 개요

Confluent 플랫폼의 핵심은 다음과 같습니다. https://kafka.apache.org/["아파치 카프카"^] 가장 인기 있는 오픈소스 분산 스트리밍 플랫폼입니다.  카프카의 주요 기능은 다음과 같습니다.

* 레코드 스트림을 게시하고 구독합니다.
* 장애에 견딜 수 있는 방식으로 레코드 스트림을 저장합니다.
* 레코드 스트림을 처리합니다.


Confluent Platform에는 기본적으로 스키마 레지스트리, REST 프록시, 100개 이상의 사전 구축된 Kafka 커넥터, ksqlDB가 포함되어 있습니다.



=== Confluent 플랫폼의 엔터프라이즈 기능 개요

* *Confluent 제어 센터.*  Kafka를 관리하고 모니터링하기 위한 GUI 기반 시스템입니다.  Kafka Connect를 쉽게 관리하고 다른 시스템에 대한 연결을 생성, 편집, 관리할 수 있습니다.
* *Kubernetes용 Confluent.*  Kubernetes용 Confluent는 Kubernetes 운영자입니다.  쿠버네티스 운영자는 특정 플랫폼 애플리케이션에 대한 고유한 기능과 요구 사항을 제공하여 쿠버네티스의 오케스트레이션 기능을 확장합니다.  Confluent Platform의 경우, 여기에는 Kubernetes에서 Kafka의 배포 프로세스를 크게 단순화하고 일반적인 인프라 수명 주기 작업을 자동화하는 것이 포함됩니다.
* *Kafka에 대한 합류 커넥터.*  커넥터는 Kafka Connect API를 사용하여 Kafka를 데이터베이스, 키-값 저장소, 검색 인덱스, 파일 시스템 등의 다른 시스템에 연결합니다.  Confluent Hub에는 가장 인기 있는 데이터 소스와 싱크에 대한 다운로드 가능한 커넥터가 있으며, 여기에는 Confluent Platform에서 이러한 커넥터의 완전히 테스트되고 지원되는 버전이 포함됩니다.  더 자세한 내용은 다음을 참조하세요. https://docs.confluent.io/home/connect/userguide.html["여기"^] .
* *자체 균형 클러스터.*  자동화된 부하 분산, 장애 감지 및 자체 복구 기능을 제공합니다.  필요에 따라 브로커를 추가하거나 해제하는 데 대한 지원을 제공하며, 수동 조정은 필요하지 않습니다.
* *합류 클러스터 연결.*  링크 브리지를 통해 클러스터를 직접 연결하고 한 클러스터의 주제를 다른 클러스터로 미러링합니다.  클러스터 연결을 통해 다중 데이터 센터, 다중 클러스터 및 하이브리드 클라우드 배포 설정이 간소화됩니다.
* *Confluent 자동 데이터 밸런서.*  클러스터 내의 브로커 수, 파티션 크기, 파티션 수, 리더 수를 모니터링합니다.  이 기능을 사용하면 클러스터 전체에서 균일한 작업 부하를 생성하기 위해 데이터를 이동할 수 있으며, 재조정하는 동안 프로덕션 작업 부하에 미치는 영향을 최소화하기 위해 재조정 트래픽을 조절할 수 있습니다.
* *합류 복제기.*  여러 데이터 센터에서 여러 Kafka 클러스터를 유지 관리하는 것이 그 어느 때보다 쉬워졌습니다.
* *계층화된 스토리지.*  선호하는 클라우드 공급업체를 사용하여 대용량의 Kafka 데이터를 저장할 수 있는 옵션을 제공하므로 운영 부담과 비용이 줄어듭니다.  계층형 스토리지를 사용하면 비용 효율적인 개체 스토리지에 데이터를 보관하고, 더 많은 컴퓨팅 리소스가 필요할 때만 확장 브로커를 사용할 수 있습니다.
* *Confluent JMS 클라이언트.*  Confluent Platform에는 Kafka용 JMS 호환 클라이언트가 포함되어 있습니다.  이 Kafka 클라이언트는 Kafka 브로커를 백엔드로 사용하여 JMS 1.1 표준 API를 구현합니다.  이 기능은 JMS를 사용하는 레거시 애플리케이션이 있고 기존 JMS 메시지 브로커를 Kafka로 교체하려는 경우에 유용합니다.
* *Confluent MQTT 프록시.*  중간에 MQTT 브로커가 필요 없이 MQTT 장치 및 게이트웨이에서 Kafka로 직접 데이터를 게시하는 방법을 제공합니다.
* *Confluent 보안 플러그인.*  Confluent 보안 플러그인은 다양한 Confluent Platform 도구와 제품에 보안 기능을 추가하는 데 사용됩니다.  현재 Confluent REST 프록시에 사용할 수 있는 플러그인이 있는데, 이 플러그인은 들어오는 요청을 인증하고 인증된 주체를 Kafka에 대한 요청에 전파하는 데 도움이 됩니다.  이를 통해 Confluent REST 프록시 클라이언트는 Kafka 브로커의 멀티테넌트 보안 기능을 활용할 수 있습니다.

